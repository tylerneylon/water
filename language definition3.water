# language definition3.water
#
# A syntax specification for reading language definition files.
# Kind of inception, I know.
#
# Objects:
#  bin talks to the dynamic process
#  parse talks to the parser
#    parse.push_mode(mode.name, opts) adds new opts to the current
#    parse.modes is a list with the mode stack, oldest-first
#  mode is a synonym for parse.mode, which has:
#    mode.id and mode.<opt>, so mode[s] refers to what was sent in as opts[s]
#  tokens is a list of the parsed objects, with special treatment for regex's
#  compiler is a global any-type object reserved for sharing data
#    I might consider some scoping rules for the compiler object.
#
# I can consider using 'src' in place of 'code'.
#
# : (commands)
#  is a set of python commands to be run as soon as the rule is parsed
#
# = (string)
#  is a shortcut for bin.run(string) in a : block
#
# parse.push_mode(mode.id, opts) pushes mode.id onto the parser mode stack
#   and opts is a dict that is added to the mode object.
#
# A seq rule ending in -| is a mode rule. It's expected to push a mode, and
#   is considered to be parsed when that mode is popped. The return value is
#   stored in mode_result.
#   Note that the : code block is always run when the full rule is parsed, so
#   mode rules need a start: code block that's run just before -| is parsed,
#   and this is where we expect the mode to be pushed.
#
# Calling an unrecognized method on an OrRule delegates it to whatever rule was
#   resolved to. This should also work with the str method.
#
# The only rule name known by the core is 'phrase', and it just keeps on
# parsing in phrases. The standard setup will try to make it so that
# we only need to redefine 'statement', and possibly 'comment'.
#
# Note on strings:
#   "-delimited strings are regex's, '-ones are literals.
#   For "-strings, the parser converts \" to an internal " and otherwise
#   leaves escaped characters the same, which are converted within python
#   to whatever they represent. For '-strings, \' is still converted, also by
#   the parser, but otherwise everything else stays exactly the same.
#
# TODO
# * In many cases, I have \s where I mean \s but not \n.
# * Drop dbg.topics references.
#

# TODO I need mode.indent to be defined at startup now.
#      This means preserving global opts between refreshes.
>: mode.indent = ''

>
  phrase -> statement | comment | blank | grammar
  blank ->
    "[ \t]*\n"
  comment ->
    "#[^\n]*\n"
  statement -> False
  grammar -> command | global_grammar | mode_grammar
  command ->
    '>:' code_block
    : exec('def _tmp():' + code_block.src()); _tmp()
  global_grammar ->
    ">\n(?=(\s+))" -|
    start:
      parse.push_mode('lang_def', {'indent': tokens[0][1], 'name': ''})
      mode.new_rules = []
  mode_grammar ->
    '> ' word "\n(?=(\s+))" -|
    start:
      opts = {'name': word.str(), 'indent': tokens[2][1]}
      parse.push_mode('lang_def', opts)
      mode.new_rules = []
  word ->
    "[A-Za-z_]\w*"
  code_block -> indented_code_block | rest_of_line 
  rest_of_line ->
    "[^\n]*\n"
  indented_code_block ->
    "\s*\n(?=(%(indent)s\s+))" -|
    = mode_result
    start:
      opts = {'indent': tokens[0][1]}
      parse.push_mode('nested_code_block', opts)
      mode.src = ['\n']

> lang_def
  phrase -> indented_rule |: return parse.pop_mode(mode.new_rules)
  indented_rule ->
    "%(indent)s" rule
    : mode.new_rules.append(rule)
  rule -> false_rule | or_rule | seq_rule
  false_rule ->
    word " ->\s+False[ \t]*\n"
    : parse.false_rule(word.str(), mode=mode.name)
  or_rule ->
    word ' -> ' or_list
    : parse.or_rule(word.str(), or_list.list(), mode=mode.name)
  or_list -> multi_or_list | or_list_end
  or_list_end ->
    rule_name "[ \t]*\n"
    list: return rule_name.list()
  multi_or_list -> std_multi_or_list | else_multi_or_list
  std_multi_or_list ->
    rule_name ' | ' or_list
    list: return rule_name.list() + or_list.list()
  else_multi_or_list ->
    rule_name ' |: ' rest_of_line
    list: return rule_name.list() + [':' + rest_of_line.str()]
  rule_name ->
    word
    list: return [word.str()]
  seq_rule ->
    word " ->\n%(indent)s(\s+)" seq -|
    start: 
      opts = {'indent': mode.indent + tokens[1][1]}
      parse.push_mode('rule_block', opts)
      mode.rule = parse.seq_rule(word.str(), seq.list(), mode=mode.name)
      mode.items = []
  seq -> item_end | mode_result_end | item_list
  item_end ->
    item "[ \t]*\n"
    list: return item.list()
  mode_result_end ->
    '-|' "[ \t]*\n"
    list: return ['-|']
  item_list ->
    item ' ' seq
    list: return item.list() + seq.list()
  item -> str | rule_name
  str ->
    "['\"]" -|
    start:
      parse.push_mode('str', {'endchar': tokens[0][0]})
      mode.dt = dbg.topics
      dbg.topics = []
      mode.chars = [mode.endchar]
    list: return [self.src()]

> rule_block
  phrase -> indented_rule_item |: return parse.pop_mode(mode.items)
  indented_rule_item ->
    "%(indent)s" rule_item
    : mode.items.append(rule_item)
  rule_item -> bin_item | parse_item | method_item
  bin_item ->
    '=' rest_of_line
    : mode.rule.add_fn('str', 'return ' + rest_of_line.str())
  parse_item ->
    ':' code_block
    : mode.rule.add_fn('parsed', code_block.src())
  method_item ->
    word ':' code_block
    : mode.rule.add_fn(word.str(), code_block.src())
 
> str
  phrase -> escape_seq | char
  escape_seq ->
    "\\\\(.)"
    :
      if tokens[0][1] != mode.endchar:
        mode.chars.append("\\")
      mode.chars.append(tokens[0][1])
  char ->
    "."
    :
      c = tokens[0][0]
      mode.chars.append(c)
      if c == mode.endchar:
        dbg.topics = mode.dt
        parse.pop_mode(''.join(mode.chars))

> nested_code_block
  phrase -> indented_code_line |: return parse.pop_mode(''.join(mode.src))
  indented_code_line ->
    "%(indent)s" code_line
  code_line ->
    "[^\n]*\n"
    : mode.src.append('  ' + tokens[0])

    
