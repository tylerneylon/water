# language definition3.water
#
# A syntax specification for reading language definition files.
# Kind of inception, I know.
#
# Objects:
#  api talks to the dynamic process
#  parse talks to the parser
#    parse.push_mode(mode.name, mode.opts) adds new opts to the current
#    parse.modes is a list with the mode stack, oldest-first
#  mode is a synonym for parse.mode, which has mode.name and mode.opts
#  tokens is a list of the parsed objects, with special treatment for regex's
#  compiler is a global any-type object reserved for sharing data
#    I might consider some scoping rules for the compiler object.
#
# api is a bad name; maybe rename to bin for binary?
# If I use bin for an object, I could also use src for source.
#
# : (commands)
#  is a set of python commands to be run as soon as the rule is parsed
#
# = (string)
#  is a shortcut for bin.run(string) in a : block
#

>
  phrase -> blank | comment | statement | lang_def_start
  blank ->
    "\n"
  comment ->
    "#[^\n]*\n"
  lang_def_start -> global_start | mode_start
  global_start ->
    ">\n(?=(\s+))"
    : parse.push_mode('lang_def', {'indent': tokens[0][1]})
  mode_start ->
    "> " word "\n(?=(\s+))"
    :
      opts = {'name': word.str, 'indent': tokens[2][1]}
      parse.push_mode('lang_def', opts)
  word ->
    "[A-Za-z_]\w*"

> lang_def
  phrase -> indented_rule_start |: parse.pop_mode()
  indented_rule_start ->
    '%(indent)s' rule_start
  rule_start -> or_rule | seq_rule_start | mode_rule_start
  or_rule ->
    word '->' or_list
  or_list -> rule_name | multi_or_list
  multi_or_list -> std_multi_or_list | else_multi_or_list
  std_multi_or_list ->
    rule_name '|' or_list
  else_multi_or_list ->
    rule_name '|:' command
  rule_name -> word
  command ->
    "[^\n]*\n"
  seq_rule_start ->
    word " ->\n%(indent)s(?=(\s+))" seq
    : 
      opts = {'indent': mode.opts.indent + tokens[1][1]}
      parse.push_mode('rule_block', opts)
  seq -> item | item_list
  item -> str | rule_name
  str -mode-> "['\"]" 
    : parse.push_mode('str', {'endchar': tokens[0][0]})
  item_list ->
    item ' ' seq
  mode_rule_start ->
    word " -mode-> " str
    : 
      opts = {'indent': mode.opts.indent + tokens[1][1]}
      parse.push_mode('rule_block', opts)

> rule_block
  phrase -> indented_rule_piece |: parse.pop_mode()
  indented_rule_piece ->
    "%(indent)s" rule_piece
  rule_piece -> bin_piece | parse_piece | method_piece
  # TODO
  
> str
  : mode.chars = []  # TODO add a grammar for this sort of thing
  phrase -> escape_seq | char
  escape_seq ->
    "\\\\(.)"
    : mode.chars.append(tokens[0][1])
  char ->
    "."
    :
      c = tokens[0][0]
      mode.chars.append(c)
      if c == mode.endchar: parse.pop_mode(''.join(mode.chars))

    
