# Comment
# A program is always a series of statements.
# This way new grammar rules can be defined
# between statements.

# Empty lines are skipped by default.
# A single > starts an indented lang spec block.
# Or rules can be on one line.
# Sequence rules use blocks where line 1 is the sequence,
# line 2 is the string returned by .code(), and any
# remaining lines are other methods.
# I decided to make 'code' be called by default when
# a parse object is referred to on its own.
# Internally, maybe I can override a to_str type method
# to achieve this.
>
  statement -> assignment | for_loop | print_statement
  assignment -> direct_assignment | incremental_assignment
  direct_assignment ->
    identifier '= expression
    = "%s = %s" % (identifier.left_name, expression)
  incremental_assignment ->
    identifier '+= expression
    = "%s += %s" % (identifier.existing_name, expression)
  expression -> identifier | number
  for_loop ->
    'for '( statement '; conditional '; statement ') statement
    = "%s\nwhile (%s):\n%s%s" % (statement[0], conditional, api.block(statement[2]), api.block(statement[1]))
  conditional ->
    expression '< expression
    = "%s < %s" % (expression[0], expression[1])
  print_statement ->
    'print identifier
    = "print %s" % identifier.existing_name
  identifier ->
    "[A-Za-z_]\w*"
    = left_name:
      return compiler.symbols.setdefault(self.str, api.new_sym())
    existing_name:
      if self.str not in compiler.symbols:
        return api.err('Undefined identifier: ' + self.str)
      return compiler.symbols[self.str]
  number ->
    "[0-9]+"
    = self.str

# Later I plan to add a kind of not rule type which would allow me to
# say something like "an identifier cannot be a keyword", and this would
# be implmented internally by first checking to see if an identifier
# appeared to be a keyword, and if so, saying it did not match as an
# identifier.

s = 0
for (i = 0; i < 100; i += 1) s += i
print s
