# 14.water
#
# A sample toward js:tgp.
#

>:
  run.run("symbols = {}\n")
  run.run("def log_fn(str_obj): print(str_obj['value'])\n")
  run.run("log_obj = {'type': 'fn', 'value': log_fn}\n")
  run.run("symbols['console'] = {'type': 'obj', 'value': {'log': log_obj}}\n")
  run.run("def make_locals():\n  lo = {}\n  lo.update(symbols)\n  return lo\n")

# If this general statement block is common, maybe find a way to pull out this
# statement -> stmnt pattern.
# It would be nice to combine or and seq things in one rule.
# It would be nice to allow an or rule to possibly match the empty string.
# The last request could use a True rule as a subrule.
# It might be good to support a way to do basic checks on a grammar, such
# as noticing missing rules. Maybe a module could do this.
# Also detecting definite loops. I'd like to formally define that if I can.
#
# Later, the first statement rule should be as below.
# For now, I'll leave it without methods so we're just parsing, not running.
#  statement ->
#    stmnt
#    : run.run(stmnt)
#    add_code: run.add(stmnt)
>
  statement ->
    stmnt
  stmnt -> expr_stmnt_w_semicolon | for_stmnt
  expr_stmnt_w_semicolon ->
    expr_stmnt ';'
  expr_stmnt -> delete_stmnt | nondelete_expr_stmnt
  delete_stmnt -> False
  nondelete_expr_stmnt -> fn_call | assignment
  fn_call ->
    lvalue invocations
  invocations -> multi_invo | invocation
  multi_invo ->
    invocation invocations
  invocation -> empty_invocation | nonempty_invocation
  empty_invocation ->
    '(' ')'
  nonempty_invocation ->
    '(' expr_list ')'
  expr_list -> multi_expr_list | expr
  multi_expr_list ->
    expr ',' expr_list
  assignment -> # TODO
  literal -> num_lit | str_lit | obj_lit | arr_lit | fn | regex_lit
  num_lit -> False # TODO
  str_lit ->
    "['\"]" .-str_lit
    mode_params: return {'endchar': tokens[0][0]}
    add_code: run.add("{'type': 'str', 'value': %s}" % self.src())
  obj_lit -> False
  arr_lit -> False
  fn -> # TODO
  regex_lit -> False
  for_stmnt ->
    'for' '(' for_loop_setup ')' -block
  for_loop_setup -> for_x_in_y_setup | for_init_cond_inc_setup
  for_x_in_y_setup -> False
  for_init_cond_inc_setup ->
    expr_stmnt ';' expr ';' expr_stmnt
  expr -> expr_with_suffices | expr_no_suffix
  expr_with_suffices ->
    expr_no_suffix suffices
  suffices -> multi_suffices | one_suffix
  multi_suffices ->
    one_suffix multi_suffices
  one_suffix -> op_right_side | ternary_tail | invocation | refinement
  expr_no_suffix -> literal | name | paren_expr | prefix_expr | new_expr | delete_expr
  op_right_side -> False
  ternary_tail -> False
  refinement -> # TODO
  name -> # TODO
  paren_expr ->
    '(' expr ')'
  prefix_expr ->
    prefix_op expr
  new_expr -> False
  delete_expr -> False
  prefix_op -> # TODO

> block
  statement -> close_brace | stmnt
  close_brace ->
    '}'
    : parse.pop_mode()
    add_code: pass
    
# ---------------------------------------
# stuff above here is to keep

  fn_call -> deep_fn_call | one_fn_call
  deep_fn_call ->
    fn_call invocation
  one_fn_call ->
    lvalue invocation
  assignment ->
    
  statement ->
    stmnt
    : run.run(stmnt)
    add_code: run.add(stmnt)
  stmnt ->
    stmnt_no_smcln "(;)?([ \t]*\n)?"
    add_code: run.add(stmnt_no_smcln)
  stmnt_no_smcln -> func_def | assign | while | expr
  func_def ->
    'function' ident '(' params ')' '{' -block
    add_code:
      src_names, code_names = params.names()
      run.add("def fn(%s):\n" % ','.join(code_names))
      run.push_indent('  ')
      run.add("symbols = make_locals()\n")
      for i in range(len(src_names)):
        run.add("symbols['%s'] = %s\n" % (src_names[i], code_names[i]))
      for r in mode_result: run.add(r)
      run.pop_indent()
      run.add("symbols['%s'] = {'type': 'fn', 'value': fn}\n" % ident.src())
  assign -> direct_assign | inc_assign
  direct_assign ->
    "(var)?" ident '=' expr
    add_code:
      run.add("symbols['%s'] = " % ident.src())
      run.add(expr, "\n")
  inc_assign ->
    ident inc_op
    add_code:
      run.add(ident, "['value'] ", inc_op, "\n")
  while ->
    'while' '(' cond ')' '{' -block
    add_code:
      run.add("while ", cond, ":\n")
      run.push_indent('  ')
      for r in mode_result: run.add(r)
      run.pop_indent()
  call ->
    ident '(' args ')'
    add_code:
      run.add("symbols['%s']['value'](" % ident.src())
      run.add(args)
      run.add(")\n")
  ident ->
    "[A-Za-z_]\w*"
    names: return [self.src()], ['param0']
    add_code:
      run.add("symbols['%s']" % self.src())
  params -> multi_params | ident
  multi_params ->
    ident ',' params
    src_names: return [ident.src()] + params.src_names()
    names:
      src = self.src_names()
      return src, ['param%d' % i for i in range(len(src))]
  expr -> obj_elem | call | var | js_str | num
  inc_op ->
    '--'
    add_code: run.add("-= 1")
  cond ->
    expr cond_op expr
    add_code:
      run.add(expr[0], "['value']")
      run.add(' %s ' % cond_op.src())
      run.add(expr[1], "['value']")
  args -> multi_args | expr
  multi_args ->
    expr ',' args
  obj_elem ->
    var '.' ident
    add_code:
      run.add("symbols['%s']['value']['%s']" % (var, ident.src()))
  var ->
    ident
    add_code: run.add("symbols['%s']" % ident.src())
  js_str ->
    "['\"]" .-js_str
    mode_params: return {'endchar': tokens[0][0]}
    add_code: run.add("{'type': 'str', 'value': %s}" % self.src())
  num ->
    "[0-9]+"
    add_code: run.add("{'type': 'num', 'value': %s}" % self.src())
  cond_op ->
    '>'

# So far this is for the body fo a func_def or while.
> block
  statement -> close_brace | stmnt
  close_brace ->
    '}'
    : parse.pop_mode()
    add_code: pass

> str_lit
  phrase -> escape_seq | char
  escape_seq ->
    "\\\\(.)"
  char ->
    "."
    :
      if tokens[0][0] == mode.endchar: parse.pop_mode()

>: set_prefix(r'\s*') 


function print2nd(x, y) {
  console.log(y);
}

print2nd(123, 456);

print_twice = function (a) { print2nd(a, a); print2nd(a, a); }

print_twice('line 1\nline 2');

intA = 2384;
intB = +24;
intC = -1923;
boolA = !0;
strA = typeof print2nd;
strB = typeof {};

objA = {ilike: "pizza", butnot: 'eggs', '1729': true}

function yes_or_no(x) {
  if (x) {
    console.log('yes');
  } else {
    console.log('no');
  }
}

yes_or_no(objA['1729']);
yes_or_no(objA.ilike);

floatA = 3.141;
floatB = 6.022e23;

console.log(floatA);
console.log(floatB);
