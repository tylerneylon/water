# layer2.water
#
# Anything built on type of layer1. For now this is just
# substitution syntax.
#
# TODO Be able to clean up the syntax that looks like this:
#  * mode_result.tokens[1].tokens[1].src()
#

##############################################################
# Add >! syntax for substitutions.
##############################################################

>:
  env._next_subst_number = 0
  def new_subst_name():
    name = '_subst_' + str(env._next_subst_number)
    env._next_subst_number += 1
    return name
  env._new_subst_name = new_subst_name

>
  substitution -->
    '>! ' word "\n(?=(\s+))" -subst_block
    mode_params:
      return {'indent': tokens[2][1], 'rule_name': word}
    :
      subst_name = env._new_subst_name()
      parse.add_subst('>\n  ', subst_name, ' -->\n')
      parse.add_subst('    ', mode_result.tokens[0].tokens[1].src(), '\n')
      parse.add_subst('    : parse.add_subst(')
      parse.add_subst(mode_result.tokens[1].tokens[1].src(), ')\n\n')
      parse.prepend_to_or(word.src(), subst_name)

> subst_block
  phrase -->
    indent_line indent_line
    : parse.pop_mode()
  indent_line -->
    "%(indent)s" line_body "\n"
  line_body -->
    "[^\n]*"

>
  phrase =| substitution

##############################################################
# Add -> syntax for combined or/seq rules.
##############################################################

>:
  env._next_inner_rule_number = 0
  def new_inner_rule_name():
    name = '_inner_' + str(env._next_inner_rule_number)
    env._next_inner_rule_number += 1
    return name
  env._new_inner_rule_name = new_inner_rule_name

> lang_def
  combined_rule -->
    word ' -> ' combined_rule_list "[ \t]*\n"
    :
      seqs = combined_rule_list.list()
      names = [env._new_inner_rule_name() for i in range(len(seqs))]
      name_list_str = ' | '.join(names)
      add_subst('%s --> %s\n' % (word, name_list_str))
      ind = mode.indent
      for i, s in enumerate(seqs):
        add_subst('%s%s -->\n%s  %s\n' % (ind, names[i], ind, seqs[i]))
  combined_rule_list --> or_of_seqs | one_seq
  or_of_seqs -->
    seq ' | ' combined_rule_list
    list: return [seq] + combined_rule_list.list()
  one_seq -->
    seq
    list: return [seq]
  
> lang_def
  rule =| combined_rule

