# layer2.water
#
# Anything built on type of layer1. For now this is just
# substitution syntax.
#
# TODO Be able to clean up the syntax that looks like this:
#  * mode_result.tokens[1].tokens[1].src()
#

##############################################################
# Add >! syntax for substitutions.
##############################################################

>:
  env._next_subst_number = 0
  def new_subst_name():
    name = '_subst_' + str(env._next_subst_number)
    env._next_subst_number += 1
    return name
  env._new_subst_name = new_subst_name

>
  substitution -->
    '>! ' word "\n(?=(\s+))" -subst_block
    mode_params:
      return {'indent': tokens[2][1], 'rule_name': word}
    :
      subst_name = env._new_subst_name()
      parse.add_subst('>\n  ', subst_name, ' -->\n')
      parse.add_subst('    ', mode_result[0].tokens[0].tokens[1].src(), '\n')
      parse.add_subst('    : parse.add_subst(')
      parse.add_subst(mode_result[0].tokens[1].tokens[1].src(), ')\n\n')
      parse.prepend_to_or(word.src(), subst_name)

> subst_block
  phrase -->
    indent_line indent_line
    : parse.pop_mode()
  indent_line -->
    "%(indent)s" line_body "\n"
  line_body -->
    "[^\n]*"

>
  phrase =| substitution

##############################################################
# Add -> syntax for combined or/seq rules.
##############################################################

>:
  env._next_inner_rule_number = 0
  def new_inner_rule_name():
    name = '_inner_' + str(env._next_inner_rule_number)
    env._next_inner_rule_number += 1
    return name
  env._new_inner_rule_name = new_inner_rule_name

> indented_block
  phrase --> indented_line |: parse.pop_mode()
  indented_line -->
    "%(indent)s[^\n]*\n"

> opt_indented_block
  phrase --> indented_block |: parse.pop_mode()
  indented_block -->
    "(?=(%(indent)s\s+))" -indented_block
    mode_params:
      params = {'indent': tokens[0][1]}
      return params
    : parse.pop_mode()

> lang_def
  combined_rule -->
    word ' -> ' combined_rule_list "[ \t]*\n" -opt_indented_block
    :
      seqs = combined_rule_list.list()
      names = [env._new_inner_rule_name() for i in range(len(seqs))]
      name_list_str = ' | '.join(names)
      add_subst('%s --> %s\n' % (word, name_list_str))
      add_subst(src(mode_result))
      ind = mode.indent
      for i, s in enumerate(seqs):
        add_subst('%s%s -->\n%s  %s\n' % (ind, names[i], ind, seqs[i]))
  combined_rule_list --> or_of_seqs | one_seq
  or_of_seqs -->
    seq ' | ' combined_rule_list
    list: return [seq] + combined_rule_list.list()
  one_seq -->
    seq
    list: return [seq]
  
> lang_def
  rule =| combined_rule

##############################################################
# Add (( )) syntax for groups.
##############################################################

# TODO
# I'm realizing that there's no awesome way to do this yet.
# The solution I currently like best is to add something like
# Lua's loadstring function, and use that to inject higher-level
# substitutions without altering the current parse stack.
# This will probably involve some refactoring as the current
# code setup is full of side effects in globals :(
# At first glance, the only side effects that really need to
# stay as such are:
#   all_rules, rules, parse, and env
# Everything else is sort of "per-stack" meaning we need another
# copy to handle nested parsing.

> lang_def
  group_item -->
    '(( ' combined_rule_list ' ))'
    :
      name = env._new_inner_rule_name()
      add_subst(name)
  item_no_dot =| group_item
