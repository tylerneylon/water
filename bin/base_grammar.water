>: mode.indent = ''
>: parse.bool_rule('False', False)
>: bool_rule('False', False)
>: parse.bool_rule('Empty', True)
>: bool_rule('Empty', True)
>: or_rule('phrase', ['statement', 'comment', 'blank', 'grammar'], mode='')
>: seq_rule('blank', ['"[ \\t]*\\n"'], mode='')
>: seq_rule('comment', ['"#[^\\n]*\\n"'], mode='')
>: or_rule('statement', ['False'], mode='')
>: or_rule('grammar', ['command', 'global_grammar', 'mode_grammar'], mode='')
>: r = seq_rule('command', ["'>:'", 'code_block'], mode='');  r.add_fn('parsed', ' parse.command(code_block.src())\n')
>: r = seq_rule('global_grammar', ['">\\n(?=(\\s+))"', '-lang_def'], mode='');  r.add_fn('mode_params', "\n      return {'indent': tokens[0][1], 'name': ''}\n")
>: r = seq_rule('mode_grammar', ["'> '", 'word', '"\\n(?=(\\s+))"', '-lang_def'], mode='');  r.add_fn('mode_params', "\n      return {'name': word.src(), 'indent': tokens[2][1]}\n")
>: seq_rule('word', ['"[A-Za-z_]\\w*"'], mode='')
>: or_rule('code_block', ['indented_code_block', 'rest_of_line'], mode='')
>: seq_rule('rest_of_line', ['"[^\\n]*\\n"'], mode='')
>: r = seq_rule('indented_code_block', ['"\\s*\\n(?=(%(indent)s\\s+))"', '-nested_code_block'], mode='');  r.add_fn('mode_params', "\n      return {'indent': tokens[0][1]}\n")
>: or_rule('phrase', ['indented_rule', ':parse.pop_mode()\n'], mode='lang_def')
>: seq_rule('indented_rule', ['"%(indent)s"', 'rule'], mode='lang_def')
>: or_rule('rule', ['prepend_to_or', 'or_rule', 'seq_rule'], mode='lang_def')
>: r = seq_rule('prepend_to_or', ['word', "' =| '", 'word', '"[ \\t]*\\n"'], mode='lang_def');  r.add_fn('parsed', ' parse.prepend_to_or(word[0].src(), word[1].src(), mode=mode.name)\n')
>: r = seq_rule('or_rule', ['word', "' -> '", 'or_list'], mode='lang_def');  r.add_fn('parsed', ' parse.or_rule(word.src(), or_list.list(), mode=mode.name)\n')
>: or_rule('or_list', ['multi_or_list', 'or_list_end'], mode='lang_def')
>: r = seq_rule('or_list_end', ['rule_name', '"[ \\t]*\\n"'], mode='lang_def');  r.add_fn('list', ' return rule_name.list()\n')
>: or_rule('multi_or_list', ['std_multi_or_list', 'else_multi_or_list'], mode='lang_def')
>: r = seq_rule('std_multi_or_list', ['rule_name', "' | '", 'or_list'], mode='lang_def');  r.add_fn('list', ' return rule_name.list() + or_list.list()\n')
>: r = seq_rule('else_multi_or_list', ['rule_name', "' |: '", 'rest_of_line'], mode='lang_def');  r.add_fn('list', " return rule_name.list() + [':' + rest_of_line.src()]\n")
>: r = seq_rule('rule_name', ['word'], mode='lang_def');  r.add_fn('list', ' return [word.src()]\n')
>: r = seq_rule('seq_rule', ['word', '" ->\\n%(indent)s(\\s+)"', 'seq', '-rule_block'], mode='lang_def');  r.add_fn('mode_params', "\n      params = {'indent': mode.indent + tokens[1][1]}\n      params['rule'] = parse.seq_rule(word.src(), seq.list(), mode=mode.name)\n      return params\n")
>: or_rule('seq', ['item_end', 'mode_result_end', 'item_list'], mode='lang_def')
>: r = seq_rule('item_end', ['item', '"[ \\t]*\\n"'], mode='lang_def');  r.add_fn('list', ' return item.list()\n')
>: r = seq_rule('mode_result_end', ['"\\.?-"', 'word', '"[ \\t]*\\n"'], mode='lang_def');  r.add_fn('list', ' return [tokens[0] + word.src()]\n')
>: r = seq_rule('item_list', ['item', "' '", 'seq'], mode='lang_def');  r.add_fn('list', ' return item.list() + seq.list()\n')
>: r = seq_rule('item', ['"!?(\\.)?"', 'item_no_dot'], mode='lang_def');  r.add_fn('list', ' return [self.src()]\n')
>: or_rule('item_no_dot', ['item_with_label', 'item_plain'], mode='lang_def')
>: seq_rule('item_with_label', ['item_plain', "':'", 'word'], mode='lang_def')
>: or_rule('item_plain', ['str', 'rule_name'], mode='lang_def')
>: r = seq_rule('str', ['"[\'\\"]"', '-str'], mode='lang_def');  r.add_fn('mode_params', "\n      return {'endchar': tokens[0][0]}\n");  r.add_fn('list', ' return [self.src()]\n')
>: or_rule('phrase', ['indented_rule_item', ':parse.pop_mode()\n'], mode='rule_block')
>: seq_rule('indented_rule_item', ['"%(indent)s"', 'rule_item'], mode='rule_block')
>: or_rule('rule_item', ['str_item', 'parsed_item', 'method_item'], mode='rule_block')
>: r = seq_rule('str_item', ["'='", 'rest_of_line'], mode='rule_block');  r.add_fn('parsed', " mode.rule.add_fn('str', 'return ' + rest_of_line.src())\n")
>: r = seq_rule('parsed_item', ["':'", 'code_block'], mode='rule_block');  r.add_fn('parsed', " mode.rule.add_fn('parsed', code_block.src())\n")
>: r = seq_rule('method_item', ['word', "':'", 'code_block'], mode='rule_block');  r.add_fn('parsed', ' mode.rule.add_fn(word.src(), code_block.src())\n')
>: or_rule('phrase', ['escape_seq', 'char'], mode='str')
>: seq_rule('escape_seq', ['"\\\\\\\\(.)"'], mode='str')
>: r = seq_rule('char', ['"."'], mode='str');  r.add_fn('parsed', '\n      if tokens[0][0] == mode.endchar: parse.pop_mode()\n')
>: or_rule('phrase', ['indented_code_line', ':parse.pop_mode()\n'], mode='nested_code_block')
>: seq_rule('indented_code_line', ['"%(indent)s"', 'code_line'], mode='nested_code_block')
>: seq_rule('code_line', ['"[^\\n]*\\n"'], mode='nested_code_block')
>: push_mode('');  pop_mode()
>: 
  env._next_subst_number = 0
  def new_subst_name():
    name = '_subst_' + str(env._next_subst_number)
    env._next_subst_number += 1
    return name
  env._new_subst_name = new_subst_name
>: 
  r = seq_rule('substitution', ["'>! '", 'word', '"\\n(?=(\\s+))"', '-subst_block'], mode='')
  r.add_fn('mode_params', "\n      return {'indent': tokens[2][1], 'rule_name': word}\n")
  r.add_fn('parsed', "\n      subst_name = env._new_subst_name()\n      parse.add_subst('>\\n  ', subst_name, ' ->\\n')\n      parse.add_subst('    ', mode_result.tokens[0].tokens[1].src(), '\\n')\n      parse.add_subst('    : parse.add_subst(')\n      parse.add_subst(mode_result.tokens[1].tokens[1].src(), ')\\n\\n')\n      parse.prepend_to_or(word.src(), subst_name)\n")
>: 
  r = seq_rule('phrase', ['indent_line', 'indent_line'], mode='subst_block')
  r.add_fn('parsed', ' parse.pop_mode()\n')
>: seq_rule('indent_line', ['"%(indent)s"', 'line_body', '"\\n"'], mode='subst_block')
>: seq_rule('line_body', ['"[^\\n]*"'], mode='subst_block')
>: prepend_to_or('phrase', 'substitution', '')
>: 
  push_mode('')
  pop_mode()
