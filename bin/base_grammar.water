>: mode.indent = ''
>: parse.bool_rule('False', False)
>: bool_rule('False', False)
>: parse.bool_rule('Empty', True)
>: bool_rule('Empty', True)
>: or_rule('phrase', ['statement', 'comment', 'blank', 'grammar'], mode='', list_of=None)
>: seq_rule('blank', ['"[ \\t]*\\n"'], mode='', list_of=None)
>: seq_rule('comment', ['"#[^\\n]*\\n"'], mode='', list_of=None)
>: or_rule('statement', ['False'], mode='', list_of=None)
>: or_rule('grammar', ['command', 'global_grammar', 'mode_grammar'], mode='', list_of=None)
>: r = seq_rule('command', ["'>:'", 'code_block'], mode='', list_of=None);  r.add_fn('parsed', ' parse.command(code_block.src())\n')
>: r = seq_rule('global_grammar', ['">\\n(?=(\\s+))"', '-lang_def'], mode='', list_of=None);  r.add_fn('mode_params', "\n      return {'indent': tokens[0][1], 'name': ''}\n")
>: r = seq_rule('mode_grammar', ["'> '", 'word', '"\\n(?=(\\s+))"', '-lang_def'], mode='', list_of=None);  r.add_fn('mode_params', "\n      return {'name': word.src(), 'indent': tokens[2][1]}\n")
>: seq_rule('word', ['"[A-Za-z_]\\w*"'], mode='', list_of=None)
>: or_rule('code_block', ['indented_code_block', 'rest_of_line'], mode='', list_of=None)
>: seq_rule('rest_of_line', ['"[^\\n]*\\n"'], mode='', list_of=None)
>: r = seq_rule('indented_code_block', ['"\\s*\\n(?=(%(indent)s\\s+))"', '-nested_code_block'], mode='', list_of=None);  r.add_fn('mode_params', "\n      return {'indent': tokens[0][1]}\n")
>: or_rule('phrase', ['indented_block', ':parse.pop_mode()\n'], mode='opt_rule_block', list_of=None)
>: r = seq_rule('indented_block', ['"(?=(%(indent)s\\s+))"', '-rule_block'], mode='opt_rule_block', list_of=None);  r.add_fn('mode_params', "\n      params = {'indent': tokens[0][1]}\n      return params\n");  r.add_fn('parsed', ' parse.pop_mode()\n')
>: or_rule('phrase', ['indented_rule', ':parse.pop_mode()\n'], mode='lang_def', list_of=None)
>: seq_rule('indented_rule', ['"%(indent)s"', 'rule'], mode='lang_def', list_of=None)
>: or_rule('rule', ['prepend_to_or', 'or_rule', 'seq_rule'], mode='lang_def', list_of=None)
>: or_rule('rule_tag', ['rule_with_tag', 'rule_name'], mode='lang_def', list_of=None)
>: seq_rule('rule_with_tag', ['rule_name', "'['", 'word', "']'"], mode='lang_def', list_of=None)
>: r = seq_rule('prepend_to_or', ['word', "' =| '", 'word', '"[ \\t]*\\n"'], mode='lang_def', list_of=None);  r.add_fn('parsed', ' parse.prepend_to_or(word[0].src(), word[1].src(), mode=mode.name)\n')
>: r = seq_rule('or_rule', ['rule_tag', "' --> '", 'or_list', '-opt_rule_block'], mode='lang_def', list_of=None);  r.add_fn('mode_params', "\n      params = {}\n      list_of = None if len(rule_tag.tokens) == 1 else src(rule_tag.word)\n      params['rule'] = parse.or_rule(src(rule_tag.rule_name), or_list.list(),\n                                     mode=mode.name, list_of=list_of)\n      return params\n")
>: or_rule('or_list', ['multi_or_list', 'or_list_end'], mode='lang_def', list_of=None)
>: r = seq_rule('or_list_end', ['item', '"[ \\t]*\\n"'], mode='lang_def', list_of=None);  r.add_fn('list', ' return item.list()\n')
>: or_rule('multi_or_list', ['std_multi_or_list', 'else_multi_or_list'], mode='lang_def', list_of=None)
>: r = seq_rule('std_multi_or_list', ['item', "' | '", 'or_list'], mode='lang_def', list_of=None);  r.add_fn('list', ' return item.list() + or_list.list()\n')
>: r = seq_rule('else_multi_or_list', ['item', "' |: '", 'rest_of_line'], mode='lang_def', list_of=None);  r.add_fn('list', " return item.list() + [':' + rest_of_line.src()]\n")
>: r = seq_rule('rule_name', ['word'], mode='lang_def', list_of=None);  r.add_fn('list', ' return [word.src()]\n')
>: r = seq_rule('seq_rule', ['rule_tag', '" -->\\n%(indent)s(\\s+)"', 'seq', '"[ \\t]*\\n"', '-rule_block'], mode='lang_def', list_of=None);  r.add_fn('mode_params', "\n      params = {'indent': mode.indent + tokens[1][1]}\n      list_of = None if len(rule_tag.tokens) == 1 else src(rule_tag.word)\n      params['rule'] = parse.seq_rule(src(rule_tag.rule_name), seq.list(),\n                                      mode=mode.name, list_of=list_of)\n      return params\n")
>: or_rule('seq', ['mode_result', 'item_list'], mode='lang_def', list_of=None)
>: or_rule('item_list', ['item_seq', 'item'], mode='lang_def', list_of=None)
>: r = seq_rule('item_seq', ['item', "' '", 'seq'], mode='lang_def', list_of=None);  r.add_fn('list', ' return item.list() + seq.list()\n')
>: r = seq_rule('mode_result', ['"\\.?-"', 'word'], mode='lang_def', list_of=None);  r.add_fn('list', ' return [tokens[0] + word.src()]\n')
>: r = seq_rule('no_param_mode_result', ["'='", 'word'], mode='lang_def', list_of=None);  r.add_fn('list', ' return [tokens[0] + word.src()]\n')
>: r = seq_rule('item', ['"!?(\\.)?"', 'item_no_dot'], mode='lang_def', list_of=None);  r.add_fn('list', ' return [self.src()]\n')
>: or_rule('item_no_dot', ['item_with_label', 'item_plain'], mode='lang_def', list_of=None)
>: seq_rule('item_with_label', ['item_plain', "':'", 'word'], mode='lang_def', list_of=None)
>: or_rule('item_plain', ['no_param_mode_result', 'str', 'rule_name'], mode='lang_def', list_of=None)
>: r = seq_rule('str', ['"[\'\\"]"', '-str'], mode='lang_def', list_of=None);  r.add_fn('mode_params', "\n      return {'endchar': tokens[0][0]}\n");  r.add_fn('list', ' return [self.src()]\n')
>: or_rule('phrase', ['indented_rule_item', ':parse.pop_mode()\n'], mode='rule_block', list_of=None)
>: seq_rule('indented_rule_item', ['"%(indent)s"', 'rule_item'], mode='rule_block', list_of=None)
>: or_rule('rule_item', ['str_item', 'parsed_item', 'method_item'], mode='rule_block', list_of=None)
>: r = seq_rule('str_item', ["'='", 'rest_of_line'], mode='rule_block', list_of=None);  r.add_fn('parsed', " mode.rule.add_fn('str', 'return ' + rest_of_line.src())\n")
>: r = seq_rule('parsed_item', ["':'", 'code_block'], mode='rule_block', list_of=None);  r.add_fn('parsed', " mode.rule.add_fn('parsed', code_block.src())\n")
>: r = seq_rule('method_item', ['word', "':'", 'code_block'], mode='rule_block', list_of=None);  r.add_fn('parsed', ' mode.rule.add_fn(word.src(), code_block.src())\n')
>: or_rule('phrase', ['escape_seq', 'char'], mode='str', list_of=None)
>: seq_rule('escape_seq', ['"\\\\\\\\(.)"'], mode='str', list_of=None)
>: r = seq_rule('char', ['"."'], mode='str', list_of=None);  r.add_fn('parsed', '\n      if tokens[0][0] == mode.endchar: parse.pop_mode()\n')
>: or_rule('phrase', ['indented_code_line', ':parse.pop_mode()\n'], mode='nested_code_block', list_of=None)
>: seq_rule('indented_code_line', ['"%(indent)s"', 'code_line'], mode='nested_code_block', list_of=None)
>: seq_rule('code_line', ['"[^\\n]*\\n"'], mode='nested_code_block', list_of=None)
>: push_mode('');  pop_mode()
>: 
  env._next_subst_number = 0
  def new_subst_name():
    name = '_subst_' + str(env._next_subst_number)
    env._next_subst_number += 1
    return name
  env._new_subst_name = new_subst_name
>: 
  r = seq_rule('substitution', ["'>! '", 'word', '"\\n(?=(\\s+))"', '-subst_block'], mode='', list_of=None)
  r.add_fn('mode_params', "\n      return {'indent': tokens[2][1], 'rule_name': word}\n")
  r.add_fn('parsed', "\n      subst_name = env._new_subst_name()\n      parse.add_subst('>\\n  ', subst_name, ' -->\\n')\n      parse.add_subst('    ', mode_result[0].tokens[0].tokens[1].src(), '\\n')\n      parse.add_subst('    : parse.add_subst(')\n      parse.add_subst(mode_result[0].tokens[1].tokens[1].src(), ')\\n\\n')\n      parse.prepend_to_or(word.src(), subst_name)\n")
>: 
  r = seq_rule('phrase', ['indent_line', 'indent_line'], mode='subst_block', list_of=None)
  r.add_fn('parsed', ' parse.pop_mode()\n')
>: seq_rule('indent_line', ['"%(indent)s"', 'line_body', '"\\n"'], mode='subst_block', list_of=None)
>: seq_rule('line_body', ['"[^\\n]*"'], mode='subst_block', list_of=None)
>: prepend_to_or('phrase', 'substitution', '')
>: 
  env._next_inner_rule_number = 0
  def new_inner_rule_name():
    name = '_inner_' + str(env._next_inner_rule_number)
    env._next_inner_rule_number += 1
    return name
  env._new_inner_rule_name = new_inner_rule_name
  env._rules_to_add = []
  def str_of_rules_to_add(indent):
    i = indent
    s = ""
    for grp in env._rules_to_add:
      name = grp.keys()[0]
      s += "%s%s -> %s\n" % (i, name, grp[name])
    env._rules_to_add = []
    return s
  env._str_of_rules_to_add = str_of_rules_to_add
>: or_rule('phrase', ['indented_line', ':parse.pop_mode()\n'], mode='indented_block', list_of=None)
>: seq_rule('indented_line', ['"%(indent)s[^\\n]*\\n"'], mode='indented_block', list_of=None)
>: or_rule('phrase', ['indented_block', ':parse.pop_mode()\n'], mode='opt_indented_block', list_of=None)
>: 
  r = seq_rule('indented_block', ['"(?=(%(indent)s\\s+))"', '-indented_block'], mode='opt_indented_block', list_of=None)
  r.add_fn('mode_params', "\n      params = {'indent': tokens[0][1]}\n      return params\n")
  r.add_fn('parsed', ' parse.pop_mode()\n')
>: 
  r = seq_rule('combined_rule', ['word', "' -> '", 'combined_rule_list', '"[ \\t]*\\n"', '-opt_indented_block'], mode='lang_def', list_of=None)
  r.add_fn('parsed', "\n      seqs = combined_rule_list.list()\n      names = [env._new_inner_rule_name() for i in range(len(seqs))]\n      name_list_str = ' | '.join(names)\n      add_subst('%s --> %s\\n' % (word, name_list_str))\n      add_subst(src(mode_result))\n      ind = mode.indent\n      for i, s in enumerate(seqs):\n        add_subst('%s%s -->\\n%s  %s\\n' % (ind, names[i], ind, seqs[i]))\n      add_subst(env._str_of_rules_to_add(ind))\n")
>: or_rule('combined_rule_list', ['or_of_seqs', 'one_seq'], mode='lang_def', list_of=None)
>: 
  r = seq_rule('or_of_seqs', ['seq', "' | '", 'combined_rule_list'], mode='lang_def', list_of=None)
  r.add_fn('list', ' return [seq] + combined_rule_list.list()\n')
>: 
  r = seq_rule('one_seq', ['seq'], mode='lang_def', list_of=None)
  r.add_fn('list', ' return [seq]\n')
>: prepend_to_or('rule', 'combined_rule', 'lang_def')
>: 
  r = seq_rule('group_item', ["'(( '", 'combined_rule_list', "' ))'"], mode='lang_def', list_of=None)
  r.add_fn('parsed', '\n      name = env._new_inner_rule_name()\n      add_subst(name)\n      env._rules_to_add.append({name: src(combined_rule_list)})\n')
>: prepend_to_or('item_plain', 'group_item', 'lang_def')
>: 
  r = seq_rule('question_item', ['item_plain', "'?'"], mode='lang_def', list_of=None)
  r.add_fn('parsed', "\n      name = env._new_inner_rule_name()\n      add_subst(name)\n      env._rules_to_add.append({name: src(item_plain) + ' | Empty'})\n")
>: prepend_to_or('item_no_dot', 'question_item', 'lang_def')
>: 
  def add_indents(s, mode):
    ind = mode.indent
    indented_lines = [ind + line for line in s.split('\n')]
    indented_lines[-1] = ""
    return '\n'.join(indented_lines)
  env._add_indents = add_indents
>: 
  r = seq_rule('star_item', ['item_plain', "'*'"], mode='lang_def', list_of=None)
  r.add_fn('parsed', '\n      star_rule = env._new_inner_rule_name()\n      add_subst(star_rule)\n      if (item_plain.result.name == \'rule_name\'):\n        add_subst(\':\' + src(item_plain) + \'_list\')\n      body_rule = env._new_inner_rule_name()\n      plus_rule = env._new_inner_rule_name()\n      fmt = (\'%(body_rule)s -> %(body)s\\n\'\n             \'%(star_rule)s[%(body_rule)s] --> %(plus_rule)s | Empty\\n\'\n             \'%(plus_rule)s[%(body_rule)s] -->\\n\'\n             \'  %(body_rule)s %(star_rule)s\\n\')\n      src_elts = {"star_rule": star_rule,\n                  "body_rule": env._new_inner_rule_name(),\n                  "plus_rule": env._new_inner_rule_name(),\n                  "body": src(item_plain)}\n      parse_string(env._add_indents(fmt % src_elts, mode))\n')
>: prepend_to_or('item_no_dot', 'star_item', 'lang_def')
>: 
  r = seq_rule('plus_item', ['item_plain', "'+'"], mode='lang_def', list_of=None)
  r.add_fn('parsed', "\n      name = env._new_inner_rule_name()\n      add_subst(name)\n      item_src = src(item_plain)\n      env._rules_to_add.append({name: '%s %s*' % (item_src, item_src)})\n")
>: prepend_to_or('item_no_dot', 'plus_item', 'lang_def')
>: 
  push_mode('')
  pop_mode()
